<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Julia Set Visualization | Alexander Aghili </title> <meta name="author" content="Alexander Aghili"> <meta name="description" content=""> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/prof_pic.jpg?6c6f9940b9db3e43232845430e752c5c"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="/blog/2024/JuliaSetVisualizer/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Alexander Aghili </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Julia Set Visualization</h1> <p class="post-meta"> Created in October 05, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/category/software"> <i class="fa-solid fa-tag fa-sm"></i> Software</a>   <a href="/blog/category/math"> <i class="fa-solid fa-tag fa-sm"></i> Math</a>   <a href="/blog/category/graphics"> <i class="fa-solid fa-tag fa-sm"></i> Graphics</a>   <a href="/blog/category/parallelization"> <i class="fa-solid fa-tag fa-sm"></i> Parallelization</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h3 id="introduction">Introduction</h3> <p>The Julia Set Visualizer is a project aimed at bringing to life the intricate and captivating beauty of Julia sets, which are fundamental objects in the field of complex dynamics and fractal geometry. Julia sets are named after the French mathematician Gaston Julia, who, in the early 20th century, made significant contributions to our understanding of these complex structures. The study of Julia sets not only serves as a gateway into the fascinating world of fractals but also provides deep insights into the behavior of complex systems.</p> <h3 id="background-and-mathematical-foundation">Background and Mathematical Foundation</h3> <p>Julia sets are derived from the dynamics of iterating a complex function, typically a quadratic polynomial of the form:</p> \[f_c(z) = z^2 + c\] <p>where \(z\) is a complex number and \(c\) is a complex parameter. For a given value of \(c\), the Julia set is the boundary that separates points in the complex plane that converge to a stable cycle from those that escape to infinity under repeated iteration of the function \(f_c(z)\).</p> <p>Mathematically, the Julia set can be described as the closure of the set of repelling periodic points of the function. However, a more intuitive approach is to consider the behavior of individual points in the complex plane under iteration. For a fixed \(c\), starting with a point \(z_0\), we generate a sequence \(z_1 = f_c(z_0)\), \(z_2 = f_c(z_1)\), and so on. Depending on the value of \(c\), the point may either remain bounded, forming part of the Julia set, or escape to infinity, indicating that it lies outside the Julia set.</p> <p>The visual representation of a Julia set reveals its intricate, self-similar structure—a hallmark of fractals. The appearance of the Julia set varies dramatically depending on the choice of the parameter \(c\). For some values of \(c\), the Julia set forms a connected structure, while for others, it breaks into a dust-like set of disconnected points, known as a “Cantor set.”</p> <h3 id="purpose-of-the-project">Purpose of the Project</h3> <p>The Julia Set Visualizer project is designed to allow users to explore the fascinating and diverse world of Julia sets by varying the complex parameter \(c\) and visualizing the resulting fractal patterns. Through this tool, users can gain a deeper understanding of the complex dynamics that govern these sets, as well as an appreciation for the stunning mathematical beauty that lies within them. Whether used for educational purposes, research, or simply to marvel at the aesthetics of fractals, the Julia Set Visualizer opens a window into a world where mathematics and art converge.</p> <h3 id="base-algorithm">Base Algorithm</h3> <p>The core of the Julia Set Visualizer lies in its ability to compute and color each point in a two-dimensional grid representing the complex plane. The algorithm determines whether each point belongs to the Julia set for a given complex parameter c by iterating the function \(f(z)=z^2+c\). The coloring of each point is based on the number of iterations it takes for the sequence to escape a predefined threshold. Below is a detailed explanation of the base algorithm, as illustrated by the provided C code.</p> <h4 id="color-representation-and-utilities">Color Representation and Utilities</h4> <p>The visualization requires coloring each point to represent its behavior under iteration. Colors are handled using 32-bit integers.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="nf">get_int_from_color</span><span class="p">(</span><span class="kt">int</span> <span class="n">red</span><span class="p">,</span> <span class="kt">int</span> <span class="n">green</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blue</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">red</span> <span class="o">=</span> <span class="p">(</span><span class="n">red</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x00FF0000</span><span class="p">;</span>
    <span class="n">green</span> <span class="o">=</span> <span class="p">(</span><span class="n">green</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0000FF00</span><span class="p">;</span>
    <span class="n">blue</span> <span class="o">=</span> <span class="n">blue</span> <span class="o">&amp;</span> <span class="mh">0x000000FF</span><span class="p">;</span>

    <span class="k">return</span> <span class="mh">0x00000000</span> <span class="o">|</span> <span class="n">red</span> <span class="o">|</span> <span class="n">green</span> <span class="o">|</span> <span class="n">blue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="initializing-the-color-map">Initializing the Color Map</h4> <p>A predefined color map enhances the visual appeal by assigning specific colors to different iteration counts.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">initialize_color_map</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">color_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_int_from_color</span><span class="p">(</span><span class="mi">66</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
    <span class="n">color_map</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_int_from_color</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">26</span><span class="p">);</span>
    <span class="c1">// ... additional colors ...</span>
    <span class="n">color_map</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_int_from_color</span><span class="p">(</span><span class="mi">106</span><span class="p">,</span> <span class="mi">52</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

    <span class="n">black</span> <span class="o">=</span> <span class="n">get_int_from_color</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div> <h4 id="mapping-iteration-counts-to-colors">Mapping Iteration Counts to Colors</h4> <p>Each point’s iteration count determines its color. Points that escape quickly are colored differently from those that remain bounded longer.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="nf">get_color</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">MAX_ITERATIONS</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">16</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">color_map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">black</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div> <h4 id="iterating-the-complex-function">Iterating the Complex Function</h4> <p>The heart of the algorithm computes how each point behaves under iteration of the function \(f(z) = z^2 + c\). This function takes in a coordinate on the complex plane defined by (a,b) and the complex constant c and performs the iteration up to MAX_ITERATIONS. If the absolute value of \(f(z)\) is less than some pre-defined threshold, the iteration stops. The number of iterations will determine the color using the get_color function shown above.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">color_point</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">,</span> <span class="n">ComplexNumber</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">MAX_ITERATIONS</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">u</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>

        <span class="n">n</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/JuliaSetVisualizer/JuliaSetIntro-480.webp 480w,/assets/img/JuliaSetVisualizer/JuliaSetIntro-800.webp 800w,/assets/img/JuliaSetVisualizer/JuliaSetIntro-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/JuliaSetVisualizer/JuliaSetIntro.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h3 id="cpu-parallelization">CPU Parallelization</h3> <p>Unfortanately, this process is quite slow. This process has to occur for each pixel on the screen, meaning that with screen dimensions at 1800x1200, there is a total of 2,160,000 pixels. Therefore, to increase the speed of processing, parallelization may help. My first attempt to do so involved utilizing pthreads, POSIX threads that have an easy interface in C. To parallelize the computation, I would take the numnber of threads and split screen, which is a rectangle, into smaller rectangles. For example, four threads would split the screen at half of the width and half of the height, creating four boxes. At nine threads, there would be nine even boxes that make up the entire screen space.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/JuliaSetVisualizer/BlackJulia-480.webp 480w,/assets/img/JuliaSetVisualizer/BlackJulia-800.webp 800w,/assets/img/JuliaSetVisualizer/BlackJulia-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/JuliaSetVisualizer/BlackJulia.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Definitions and bounds for the chunks(boxes):</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">uint32_t</span><span class="o">**</span> <span class="n">image_pixels</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">x_chunk</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y_chunk</span><span class="p">;</span>
    <span class="n">ComplexScene</span><span class="o">*</span> <span class="n">scene</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ChunkData</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">get_chunk_bounds</span><span class="p">(</span><span class="kt">int</span> <span class="n">screen_width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">screen_height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_chunks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chunk_row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chunk_col</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">x_min</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">y_min</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">x_max</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">y_max</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Calculate the width and height of each chunk</span>
    <span class="kt">int</span> <span class="n">chunk_width</span> <span class="o">=</span> <span class="n">screen_width</span> <span class="o">/</span> <span class="n">num_chunks</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">chunk_height</span> <span class="o">=</span> <span class="n">screen_height</span> <span class="o">/</span> <span class="n">num_chunks</span><span class="p">;</span>

    <span class="c1">// Calculate the bounds of the specified chunk</span>
    <span class="o">*</span><span class="n">x_min</span> <span class="o">=</span> <span class="n">chunk_col</span> <span class="o">*</span> <span class="n">chunk_width</span><span class="p">;</span>
    <span class="o">*</span><span class="n">x_max</span> <span class="o">=</span> <span class="o">*</span><span class="n">x_min</span> <span class="o">+</span> <span class="n">chunk_width</span><span class="p">;</span>
    <span class="o">*</span><span class="n">y_min</span> <span class="o">=</span> <span class="n">chunk_row</span> <span class="o">*</span> <span class="n">chunk_height</span><span class="p">;</span>
    <span class="o">*</span><span class="n">y_max</span> <span class="o">=</span> <span class="o">*</span><span class="n">y_min</span> <span class="o">+</span> <span class="n">chunk_height</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div> <p>Calculating each pixel in a chunk:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="nf">calculate_chunk</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">ChunkData</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">ChunkData</span><span class="o">*</span><span class="p">)</span> <span class="n">d</span><span class="p">;</span> 
   <span class="kt">int</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">;</span> 
   <span class="n">get_chunk_bounds</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">num_chunks</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">x_chunk</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">y_chunk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x_min</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y_min</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x_max</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y_max</span><span class="p">);</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x_min</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">x_max</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y_min</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">y_max</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
           <span class="n">add_pixel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">scene</span><span class="o">-&gt;</span><span class="n">bounds</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">scene</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">image_pixels</span><span class="p">);</span>
       <span class="p">}</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">run_chunk</span><span class="p">(</span><span class="n">pthread_t</span><span class="o">*</span> <span class="n">tid</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">**</span> <span class="n">ip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x_chunk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y_chunk</span><span class="p">,</span> <span class="n">ComplexScene</span><span class="o">*</span> <span class="n">scene</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ChunkData</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">ChunkData</span><span class="o">*</span><span class="p">)</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ChunkData</span><span class="p">));</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">image_pixels</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">x_chunk</span> <span class="o">=</span> <span class="n">x_chunk</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">y_chunk</span> <span class="o">=</span> <span class="n">y_chunk</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">scene</span> <span class="o">=</span> <span class="n">scene</span><span class="p">;</span>

    <span class="n">pthread_create</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">calculate_chunk</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Processing the whole set:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">calculate_pixels</span><span class="p">(</span><span class="n">ComplexScene</span><span class="o">*</span> <span class="n">scene</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">***</span> <span class="n">ip</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="o">**</span> <span class="n">image_pixels</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
    <span class="n">pthread_t</span> <span class="n">tid</span><span class="p">[</span><span class="n">num_chunks</span> <span class="o">*</span> <span class="n">num_chunks</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x_chunk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x_chunk</span> <span class="o">&lt;</span> <span class="n">num_chunks</span><span class="p">;</span> <span class="n">x_chunk</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y_chunk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y_chunk</span> <span class="o">&lt;</span> <span class="n">num_chunks</span><span class="p">;</span> <span class="n">y_chunk</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">run_chunk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">image_pixels</span><span class="p">,</span> <span class="n">x_chunk</span><span class="p">,</span> <span class="n">y_chunk</span><span class="p">,</span> <span class="n">scene</span><span class="p">);</span>
            <span class="n">k</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">num_chunks</span><span class="o">*</span><span class="n">num_chunks</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>While this initially increased the time of processing, there were quickly diminishing and then negative returns. This is because as the number of threads increases, the overhead of a context switch begins to increase in proportion to the amount of computation being performed by the thread. This is worsened because each thread does less computation as the number of threads increases. Here is a graph of the time to compute a julia set by number of threads:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/JuliaSetVisualizer/Perf-480.webp 480w,/assets/img/JuliaSetVisualizer/Perf-800.webp 800w,/assets/img/JuliaSetVisualizer/Perf-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/JuliaSetVisualizer/Perf.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>As such, while CPU parallelization has some benefit, it doesn’t solve the problem. It can be done better.</p> <h3 id="gpu-parallelization">GPU Parallelization</h3> <p>GPUs are Graphics Processing Units that can help perform mathematical process at increased speed using parallelization. A GPU can perform many math operations at the same time and faster than a CPU. Whereas a CPU might have 8 cores, modern (consumer) GPUs like NVIDIA’s RTX 4090 have 16,384 CUDA cores. To do so, we have to write GPU code. Since I have access to a NVIDIA GPU, I will be writing CUDA code which is a specific lanaguage used to interface with NVIDIA GPUs.</p> <p>The function add_pixel_kernel would calculate and add the pixel to the image array. This is doing most of the heavy lifting, although some helpers functions were translated to CUDA to work as well.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__device__</span> <span class="kt">double</span> <span class="nf">screen_map</span><span class="p">(</span><span class="kt">double</span> <span class="n">input_num</span><span class="p">,</span> <span class="kt">double</span> <span class="n">min_input</span><span class="p">,</span> <span class="kt">double</span> <span class="n">max_input</span><span class="p">,</span> <span class="kt">double</span> <span class="n">min_output</span><span class="p">,</span> <span class="kt">double</span> <span class="n">max_output</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">input_num</span> <span class="o">-</span> <span class="n">min_input</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_output</span> <span class="o">-</span> <span class="n">min_output</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_input</span> <span class="o">-</span> <span class="n">min_input</span><span class="p">)</span> <span class="o">+</span> <span class="n">min_output</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__global__</span> <span class="kt">void</span> <span class="nf">add_pixel_kernel</span><span class="p">(</span><span class="n">ComplexBounds</span><span class="o">*</span> <span class="n">scene_bounds</span><span class="p">,</span> <span class="n">ComplexNumber</span><span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">image_pixels</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">WIDTH</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">HEIGHT</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">a</span> <span class="o">=</span> <span class="n">screen_map</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">scene_bounds</span><span class="o">-&gt;</span><span class="n">min_real</span><span class="p">,</span> <span class="n">scene_bounds</span><span class="o">-&gt;</span><span class="n">max_real</span><span class="p">);</span>
        <span class="kt">double</span> <span class="n">b</span> <span class="o">=</span> <span class="n">screen_map</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">scene_bounds</span><span class="o">-&gt;</span><span class="n">min_img</span><span class="p">,</span> <span class="n">scene_bounds</span><span class="o">-&gt;</span><span class="n">max_img</span><span class="p">);</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">color_point</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
        <span class="kt">uint32_t</span> <span class="n">color</span> <span class="o">=</span> <span class="n">get_color</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">image_pixels</span><span class="p">[</span><span class="n">y</span> <span class="o">*</span> <span class="n">WIDTH</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span><span class="p">;</span>  <span class="c1">// Note: linearized indexing for 2D array</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The blockIdx, blockDim, and threadIdx help CUDA identify what components of the pixel it is calculating. The regular processing is performed, with the exception that 2D arrays aren’t supported in CUDA so linearized indexing is required. This function is called using the add_pixel function:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">add_pixel</span><span class="p">(</span><span class="n">ComplexBounds</span><span class="o">*</span> <span class="n">scene_bounds</span><span class="p">,</span> <span class="n">ComplexNumber</span><span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">image_pixels</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dim3</span> <span class="n">threadsPerBlock</span><span class="p">(</span><span class="n">THREADS_PER_BLOCK</span><span class="p">,</span> <span class="n">THREADS_PER_BLOCK</span><span class="p">);</span>
    <span class="n">dim3</span> <span class="n">numBlocks</span><span class="p">((</span><span class="n">WIDTH</span> <span class="o">+</span> <span class="n">THREADS_PER_BLOCK</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">THREADS_PER_BLOCK</span><span class="p">,</span> <span class="p">(</span><span class="n">HEIGHT</span> <span class="o">+</span> <span class="n">THREADS_PER_BLOCK</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">THREADS_PER_BLOCK</span><span class="p">);</span>

    <span class="n">add_pixel_kernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">numBlocks</span><span class="p">,</span> <span class="n">threadsPerBlock</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">scene_bounds</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">image_pixels</span><span class="p">);</span>
    <span class="n">cudaDeviceSynchronize</span><span class="p">();</span>
<span class="p">}</span>

</code></pre></div></div> <p>This calculates the number of blocks required with the given number of threads per block and runs the function add_pixel_kernel with those parameters so CUDA knows how to parallelize the work.</p> <p>GPUs are crazy fast and allow for parallelization to drastically increase the processing speed enabling real-time applications.</p> <h3 id="sdl2">SDL2</h3> <p>GPU parallelization enables quick processing of changes. Therefore, changes can be displayed quickly. Moving around the plane, zooming, changing the constant c, and animations can all be performed in a smooth experience. When waiting for a user event, a function called wait_event polls for the next user event. There are a few options.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">wait_event</span><span class="p">(</span><span class="n">ComplexScene</span> <span class="o">*</span><span class="n">scene</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">change</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">quit</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SDL_Event</span> <span class="n">event</span><span class="p">;</span>
    <span class="n">ComplexNumber</span><span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="n">scene</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">;</span>
    <span class="n">ComplexBounds</span><span class="o">*</span> <span class="n">bounds</span> <span class="o">=</span> <span class="n">scene</span><span class="o">-&gt;</span><span class="n">bounds</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">move_amount</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">SDL_PollEvent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">SDL_QUIT</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">quit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="arrow-key-press">Arrow Key Press</h4> <p>If an arrow key is pressed, this is a change to the constant c. This isn’t too complicated:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">key</span><span class="p">.</span><span class="n">keysym</span><span class="p">.</span><span class="n">sym</span> <span class="o">==</span> <span class="n">SDLK_LEFT</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">-=</span> <span class="n">move_amount</span><span class="p">;</span>
    <span class="o">*</span><span class="n">change</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">key</span><span class="p">.</span><span class="n">keysym</span><span class="p">.</span><span class="n">sym</span> <span class="o">==</span> <span class="n">SDLK_RIGHT</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">+=</span> <span class="n">move_amount</span><span class="p">;</span>
    <span class="o">*</span><span class="n">change</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">key</span><span class="p">.</span><span class="n">keysym</span><span class="p">.</span><span class="n">sym</span> <span class="o">==</span> <span class="n">SDLK_UP</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">+=</span> <span class="n">move_amount</span><span class="p">;</span>
    <span class="o">*</span><span class="n">change</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">key</span><span class="p">.</span><span class="n">keysym</span><span class="p">.</span><span class="n">sym</span> <span class="o">==</span> <span class="n">SDLK_DOWN</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">-=</span> <span class="n">move_amount</span><span class="p">;</span>
    <span class="o">*</span><span class="n">change</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="zoom">Zoom</h4> <p>Zooming is slightly more difficult. This is because instead of zooming into the center of the complex plane (0,0), we want to zoom into the center of the screen. This means finding the real and imaginary components of the screen, taking the middle, and adjusting the bounds.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">zoom</span><span class="p">(</span><span class="n">ComplexBounds</span><span class="o">*</span> <span class="n">bounds</span><span class="p">,</span> <span class="kt">double</span> <span class="n">scaling_factor</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">real_center</span> <span class="o">=</span> <span class="p">(</span><span class="n">bounds</span><span class="o">-&gt;</span><span class="n">max_real</span> <span class="o">+</span> <span class="n">bounds</span><span class="o">-&gt;</span><span class="n">min_real</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">img_center</span> <span class="o">=</span> <span class="p">(</span><span class="n">bounds</span><span class="o">-&gt;</span><span class="n">max_img</span> <span class="o">+</span> <span class="n">bounds</span><span class="o">-&gt;</span><span class="n">min_img</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="n">bounds</span><span class="o">-&gt;</span><span class="n">max_real</span> <span class="o">=</span> <span class="n">real_center</span> <span class="o">+</span> <span class="n">scaling_factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">bounds</span><span class="o">-&gt;</span><span class="n">max_real</span> <span class="o">-</span> <span class="n">real_center</span><span class="p">);</span>
    <span class="n">bounds</span><span class="o">-&gt;</span><span class="n">min_real</span> <span class="o">=</span> <span class="n">real_center</span> <span class="o">+</span> <span class="n">scaling_factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">bounds</span><span class="o">-&gt;</span><span class="n">min_real</span> <span class="o">-</span> <span class="n">real_center</span><span class="p">);</span>
    <span class="n">bounds</span><span class="o">-&gt;</span><span class="n">max_img</span> <span class="o">=</span> <span class="n">img_center</span> <span class="o">+</span> <span class="n">scaling_factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">bounds</span><span class="o">-&gt;</span><span class="n">max_img</span> <span class="o">-</span> <span class="n">img_center</span><span class="p">);</span>
    <span class="n">bounds</span><span class="o">-&gt;</span><span class="n">min_img</span> <span class="o">=</span> <span class="n">img_center</span> <span class="o">+</span> <span class="n">scaling_factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">bounds</span><span class="o">-&gt;</span><span class="n">min_img</span> <span class="o">-</span> <span class="n">img_center</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="move">Move</h4> <p>The final action is move, which calculates the movement from a mouse click and drag action. To accomplish this, a down click event is registered and the mouse coordinates are recoreded. Then, once an up click event is registered, the mouse coordinates are recorded and a difference is calculated. The difference is calculated by subtracting the second positon from the first position. However, this alone would yield numbers in the hundreds as positions on the screen are based on pixel positions. To adjust for this, I normalized the result. However, this still isn’t enough has zooming in means the screen might show an area spanning the upper and lower bounds of 64-bit floating point precision. Thus, I added one more component to scale with the current area.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">SDL_MOUSEBUTTONDOWN</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="p">.</span><span class="n">button</span><span class="p">.</span><span class="n">button</span> <span class="o">==</span> <span class="n">SDL_BUTTON_LEFT</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">;</span>
    <span class="n">SDL_GetMouseState</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y1</span><span class="p">);</span>

    <span class="n">SDL_Event</span> <span class="n">mouse_up</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">SDL_WaitEvent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mouse_up</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mouse_up</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">SDL_MOUSEBUTTONUP</span> <span class="o">&amp;&amp;</span> <span class="n">mouse_up</span><span class="p">.</span><span class="n">button</span><span class="p">.</span><span class="n">button</span> <span class="o">==</span> <span class="n">SDL_BUTTON_LEFT</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">SDL_GetMouseState</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y2</span><span class="p">);</span>

    <span class="kt">double</span> <span class="n">xdiff</span> <span class="o">=</span> <span class="p">((</span><span class="kt">double</span><span class="p">)(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">((</span><span class="kt">double</span><span class="p">)(</span><span class="n">x1</span> <span class="o">*</span> <span class="n">x1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">x2</span> <span class="o">*</span> <span class="n">x2</span><span class="p">)))</span> <span class="o">*</span> <span class="p">(</span><span class="n">bounds</span><span class="o">-&gt;</span><span class="n">max_real</span> <span class="o">-</span> <span class="n">bounds</span><span class="o">-&gt;</span><span class="n">min_real</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">ydiff</span> <span class="o">=</span> <span class="p">((</span><span class="kt">double</span><span class="p">)(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">((</span><span class="kt">double</span><span class="p">)(</span><span class="n">y1</span> <span class="o">*</span> <span class="n">y1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">y2</span> <span class="o">*</span> <span class="n">y2</span><span class="p">)))</span> <span class="o">*</span> <span class="p">(</span><span class="n">bounds</span><span class="o">-&gt;</span><span class="n">max_img</span> <span class="o">-</span> <span class="n">bounds</span><span class="o">-&gt;</span><span class="n">min_img</span><span class="p">);</span>

    <span class="n">bounds</span><span class="o">-&gt;</span><span class="n">max_real</span> <span class="o">+=</span> <span class="n">xdiff</span><span class="p">;</span>
    <span class="n">bounds</span><span class="o">-&gt;</span><span class="n">min_real</span> <span class="o">+=</span> <span class="n">xdiff</span><span class="p">;</span>
    <span class="n">bounds</span><span class="o">-&gt;</span><span class="n">max_img</span> <span class="o">+=</span> <span class="n">ydiff</span><span class="p">;</span>
    <span class="n">bounds</span><span class="o">-&gt;</span><span class="n">min_img</span> <span class="o">+=</span> <span class="n">ydiff</span><span class="p">;</span>
    <span class="o">*</span><span class="n">change</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="conclusion">Conclusion</h3> <p>The Julia Set Visualizer project provides a dynamic way to explore the complex world of fractals and the mathematical beauty that emerges from iterative processes. By combining mathematical theory, computational techniques, and graphical rendering, this project demonstrates how complex dynamics can be visualized and manipulated in real-time. I also gained a deeper understanding of parallel processing, both on CPUs and GPUs, and the importance of efficient computation in graphical applications.</p> <p>The repository with all of the code can be found below:</p> <div class="repositories d-flex flex-wrap flex-md-row flex-column justify-content-between align-items-center"> <div class="repo p-2 text-center"> <a href="https://github.com/Alexander-Aghili/JuliaSetVisualizer" rel="external nofollow noopener" target="_blank"> <img class="repo-img-light w-100" alt="Alexander-Aghili/JuliaSetVisualizer" src="https://github-readme-stats.vercel.app/api/pin/?username=Alexander-Aghili&amp;repo=JuliaSetVisualizer&amp;theme=default&amp;show_owner=false&amp;description_lines_count=1"> <img class="repo-img-dark w-100" alt="Alexander-Aghili/JuliaSetVisualizer" src="https://github-readme-stats.vercel.app/api/pin/?username=Alexander-Aghili&amp;repo=JuliaSetVisualizer&amp;theme=dark&amp;show_owner=false&amp;description_lines_count=1"> </a> </div> </div> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/QBI-Hackthon/">The Bio-Science AI Hackathon</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/Crowdstrike/">Crowdstrike - A Reflection</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/Private-Pilot/">My Journey to Become a Private Pilot</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2022/Druid-Heights/">Druid Heights</a> </li> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>let giscusTheme=determineComputedTheme(),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"Alexander-Aghili/website","data-repo-id":"R_kgDOMQoMew","data-category":"Comments","data-category-id":"DIC_kwDOMQoMe84CgkDQ","data-mapping":"pathname","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Alexander Aghili. Last updated: October 05, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.min.js" integrity="sha256-rjmgmaB99riUNcdlrDtcAiwtLIojSxNyUFdl+Qh+rB4=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-W1QMCLW1DQ"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-W1QMCLW1DQ");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-projects",title:"projects",description:"",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-repositories",title:"repositories",description:"",section:"Navigation",handler:()=>{window.location.href="/repositories/"}},{id:"nav-cv",title:"cv",description:"",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"post-julia-set-visualization",title:"Julia Set Visualization",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/JuliaSetVisualizer/"}},{id:"post-the-bio-science-ai-hackathon",title:"The Bio-Science AI Hackathon",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/QBI-Hackthon/"}},{id:"post-crowdstrike-a-reflection",title:"Crowdstrike - A Reflection",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/Crowdstrike/"}},{id:"post-my-journey-to-become-a-private-pilot",title:"My Journey to Become a Private Pilot",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/Private-Pilot/"}},{id:"post-druid-heights",title:"Druid Heights",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2022/Druid-Heights/"}},{id:"news-a-simple-inline-announcement-with-markdown-emoji-sparkles-smile",title:'A simple inline announcement with Markdown emoji! <img class="emoji" title=":sparkles:" alt=":sparkles:" src="https://github.githubassets.com/images/icons/emoji/unicode/2728.png" height="20" width="20"> <img class="emoji" title=":smile:" alt=":smile:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png" height="20" width="20">',description:"",section:"News"},{id:"news-a-long-announcement-with-details",title:"A long announcement with details",description:"",section:"News",handler:()=>{window.location.href="/news/announcement_2/"}},{id:"news-a-simple-inline-announcement",title:"A simple inline announcement.",description:"",section:"News"},{id:"projects-public-poll-mobile-app",title:"Public Poll Mobile App",description:"This is a mobile app that I developed to use as polls between my friends",section:"Projects",handler:()=>{window.location.href="/projects/2022-09-21-Public-Poll-Mobile-App/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%61%6C%65%78%61%6E%64%65%72.%77.%61%67%68%69%6C%69@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/Alexander-Aghili","_blank")}},{id:"socials-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/AlexanderAghili","_blank")}},{id:"socials-x",title:"X",description:"Twitter",section:"Socials",handler:()=>{window.open("https://twitter.com/AghiliAlexander","_blank")}},{id:"socials-discord",title:"Discord",section:"Socials",handler:()=>{window.open("https://discord.com/users/379156584275640320","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js"></script> </body> </html>